# 忘掉Class组件的声明周期
* 基于 Class 的组件作为 React 诞生之前就存在的机制, 用法已深入人心, 甚至至今为止 React 的官方文档中仍然是以 Class 组件作为基础的, 而函数组件和Hooks则是作为新特性,做了补充说明和解释.
1. 这其实有两个原因:
> 一是 React 团队尽最大努力保持 API 的稳定, 不希望给你造成一种 Class 组件将被废弃的感觉;  
> 二是大量的存量应用其实还是都是用 Class 组件实现的, 无论是对于维护者还是加入者来说, 了解 Class 组件都是很有必要的.  

2. Class 组件和函数组件是两种实现React应用的方式, 虽然它们是等价的, 但是开发的思想有很大不同. 如果你是从Class组件转换到Hooks的方式,那么很重要一点就是, 要学会忘掉 Class 组件中的声明周期概念, 千万不要将原来习惯的Class组件开发方式映射到函数组件.
> 比如如何在函数组件中实现 componentDidMount, componentDidUpdate 这样的 Class 组件才有的生命周期方法, 你应该通过理解 Hooks 的方式思考业务需求应该如何实现.  

> 为理解函数组件的执行过程, 不妨思考下React的本质: `从Model到View的映射`. 假设状态永远不变, 那么实际上函数组件就相当于是一个模板引擎, 只执行一次. 但是 React 本身正是为动态的状态变化而设计的, 而可能引起状态变化的原因基本只有两个:  
>> 1. 用户操作产生的事件, 比如点击了某个按钮.  
>> 2. 副作用产生的事件, 比如发起某个请求正确返回了.  
>> 这两种事件本身并不会导致组件的重新渲染, 但我们在这两种事件处理函数中, 一定是因为改变了某个状态, 这个状态可能是 State 或者 Context, 从而导致了 UI 的重新渲染.   
>> 对于第一种情况, 其实函数组件 和 Class 组件的思路几乎完全一样: 通过事件处理函数来改变某个状态; 对于第二种情况, 在函数组件中是通过 useEffect 这个 Hook 更加直观和语义化的方式来描述. 对应到 Class 组件, 则是通过手动判断 Props 或者 State 的变化来执行的. 
>> 比如对于例子, 一个用于显示博客文章的组件接受一个文章的 id 作为参数, 然后根据这个 id 从服务器获取文章的内容并显示出来. 那么当 id 变化的时候, 你就需要检测到这个变化, 并重新发送请求, 显示在界面上. 在 Class 组件中, 通常需要如下代码:  
```
class BlogView extends React.Component {
    // ...
    componentDidMount() {
        // 组件第一次加载时去获取 Blog 数据
        fetchBlog(this.props.id);
    }
    componentDidUpdate(prevProps) {
        if(prevProps.id !== this.props.id) {
            // 当 Blog 的 id 发生变化时去获取博客文章
            fetchBlog(this.props.id);
        }
    }
    // ...
}
```   
>> 可以看到, 在 Class 组件中, 需要在两个生命周期方法中去实现副作用, 一个是首次架子啊, 另外一个则是每次 UI 更新后. 而在函数组件中不再有生命周期的概念, 而是提供了 useEffect 这样一个 Hook 专门用来执行副作用, 因此, 只需下面的代码即可实现同样的功能:  
```
function BlogView({ id }) {
    useEffect(() => {
        // 当 id 变化时重新获取博客文章
        fetchBlog(id);
    }, [id]); // 定义了依赖项 id 
}
```  
>> 可以看到, 在函数组件中你要思考的方式永远是: `当某个状态发生变化时, 我要做什么`, 而不再是在 Class 组件中的某个生命周期方法中我要做什么.  

3. 所以如果你是从 Class 组件转型到函数组件, 那么你要做的就是忘掉 Class 组件的声明周期机制, 去逐渐习惯函数组件的思考方式. 相信这样你就能够体会到函数组件带来的直观,简洁的好处了.  

当然, 要一下子彻底转变是很难的, 你需要在实际发开中不断联系. 那具体这样才能算是用 Hooks 方式思考呢? 接下来通过对比, 当一个需求来的时候, 基于类组件的声明周期机制是如何做的, 而在函数组件中又是如何做的.  

# 重新思考组件的声明周期  
在传统的类组件中, 有专门定义的声明周期方法用于执行不用的逻辑, 那么它们在函数组件的存在的形式有是什么样的呢? 接下来看, 在函数组件中, 是如何思考组件的生命周期的.  

* 构造函数  
- 在类组件中有一个专门的方法叫 constructor, 也就是构造函数, 在里面会做一些初始化的事情, 比如设置 State 的初始状态, 或者定义一些类的实例的成员.   
- 而现在, 函数组件只是一个函数, 没有所谓的对象, 或者说类的实例这样的概念, 那自然也就没有构造函数的说法了.  
- 那么在函数组件中, 我们应该如何去做一些初始化的事情?  答案是: 函数组件基本上没有统一的初始化需要, 因为 Hooks 自己会负责自己的初始化. 比如 useState 这个 Hook, 接收的参数就是定义的 State 初始值. 而在过去的类组件中, 你通常需要在构造函数中直接设置 this.state, 也就是设置某个值来完成初始化.  
